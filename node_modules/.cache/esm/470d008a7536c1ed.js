let createServer,readFile,resolve;_753‍.w("http",[["createServer",["createServer"],function(v){createServer=v}]]);_753‍.w("fs",[["readFile",["readFile"],function(v){readFile=v}]]);_753‍.w("path",[["resolve",["resolve"],function(v){resolve=v}]]); // Importo biblioteca http
 // Importo biblioteca nativa Node para leitura de arquivos, nesta função leitura assíncrona.
 /* Biblioteca para solução de problemas de caminho, quando o passamos o caminho para 
readFile(path,(err,file)),o caminho não é referente a pasta definida como root, nesse caso src, mas sim a pasta raiz 
do projeto, uma má prática, para corrigir usaremos o resolve() */

// Crio um servidor que ouve um pedido e responde algo.
const server = createServer((request, response) => {
  switch (
    request.url // A API deve ver a URL.
  ) {
    // Caso "url.com/status": crio uma resposta com o cabeçalho de status 200 (Representa Sucesso) e digo que a reposta terá um corpo JSON
    case "/status": {
      response.writeHead(200, { "Content-Type": "application/json" });
      response.write(JSON.stringify({ status: "OK" })); // Corpo da resposta é o parse de um JSON {status:"OK"} para string
      response.end(); // Fecho o buffer de resposta
      break;
    }

    // Caso "url.com/sign-in": leio os valores a fim de retornar um possível HTML
    case "/sign-in": {
      const filePath = resolve(__dirname, "./pages/sign-in.html"); // __dirname é relativo ao root (src) -> Ler import de "path"
      //Read File para ler a página ./pages/sign-in.html, Ele pode ter um erro e precisa de ler um arquivo
      readFile(filePath, (err, file) => {
        //Se der erro na leitura
        if (err) {
          response.writeHead(500, "Can't process HTML file."); // Respondo o código 500 (erro interno da aplicação)
          response.end(); // Fecho o buffer de resposta
          return; // retorno o caso, para não rodar o resto
        }
        response.writeHead(200);
        response.write(file);
        response.end();
      });
      break;
    }
    // Caso "url.com/authenticate"
    case "/authenticate": {
      _753‍.g.console.log(request.on("data")); // Event
      response.writeHead(200, { "Content-Type": "application/json" }); // Crio uma resposta com o cabeçalho de status 200 (Representa Sucesso) e digo que a reposta terá um corpo JSON
      response.write(JSON.stringify({ status: request.on("data") })); // Corpo da resposta é o parse de um JSON {status:"OK"} para string
      response.end(); // Fecho o buffer de resposta
      break;
    }
    default: {
      response.writeHead(404, "Service not found."); // Crio uma resposta com o cabeçalho de status 404 caso a url não exista
      response.end(); // Fecho o buffer de resposta
      break;
    }
  }
});

// procces é um grande objeto que refere a tudo do processo, env remete as variáveis globais, e PORT é a variável porta
const PORT = process.env.PORT ? parseInt(process.env.PORT) : 8000;

// procces é um grande objeto que refere a tudo do processo, env remete as variáveis globais, e HOSTNAME é a variável que fala o nome da rota
const HOSTNAME = process.env.PORT || "127.0.0.1"; // O operador "||" (pipe pipe) nesse caso testa se o valor é false, 0, null, undefined ou "", caso seja ele pega o valor "127.0.0.1"

// Servidor ouve alguns argumentos, (Porta,HostName -> Passei um IP Local, função)
server.listen(PORT, HOSTNAME, () => {
  console.log(`Server is listening at http://${HOSTNAME}:${PORT}.`);
});
